<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width" />

	<title>
	MySQL - zenboss
	</title>
	<script type="text/javascript" src="js/zenboss.js"></script>
	<link rel="stylesheet" type="text/css" href="css/main.css">

</head>
<body>
<h1 id="entry_title">MySQL</h1>
<div id="entry_info">
	MySQL（发音：[ˌmaɪ ɛs kjuː ˈɛl]，但也经常读作My-SEQuel）是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被升阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购升阳微系统公司，MySQL成为Oracle旗下产品。
MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用在Internet上的中小型网站中。随着MySQL的不断成熟，它也逐渐用于更多大规模网站和应用，比如维基百科、Google和Facebook等网站。非常流行的开源软件组合LAMP中的“M”指的就是MySQL。
但被甲骨文公司收购后，Oracle大幅调涨MySQL商业版的售价，且甲骨文公司不再支持Open Solaris的发展，因此导致共享软件社区们对于Oracle是否还会持续支持MySQL社区版（MySQL之中唯一的免费版本）有所隐忧，因此原先一些使用MySQL的开源软件逐渐转向其它的数据库。
</div>

<div id="entry_contect">
<h2>INSERT语法</h2>
<zenbossCode>
<pre>
INSERT [LOW_PRIORITY |DELAYED| HIGH_PRIORITY] [IGNORE]      
[INTO]tbl_name[(col_name,...)]      VALUES ({expr| DEFAULT},...),(...),...      
[ON DUPLICATE KEY UPDATEcol_name=expr, ... ]
</pre>
或：
<pre>
INSERT [LOW_PRIORITY |DELAYED| HIGH_PRIORITY] [IGNORE]      
[INTO]tbl_name      SETcol_name={expr| DEFAULT}, ...      
[ON DUPLICATE KEY UPDATEcol_name=expr, ... ]
</pre>
或：
<pre>
INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]      
[INTO]tbl_name[(col_name,...)]      SELECT ...      
[ON DUPLICATE KEY UPDATEcol_name=expr, ... ]
</pre>

<strong>一、DELAYED的使用</strong>
使用延迟插入操作DELAYED调节符应用于INSERT和REPLACE语句。当DELAYED插入操作到达的时候，服务器把数据行放入一个队列中，并立即给客户端返回一个状态信息，这样客户端就可以在数据表被真正地插入记录之前继续进行操作了。如果读取者从该数据表中读取数据，队列中的数据就会被保持着，直到没有读取者为止。接着服务器开始插入延迟数据行（delayed-row）队列中的数据行。在插入操作的同时，服务器还要检查是否有新的读取请求到达和等待。如果有，延迟数据行队列就被挂起，允许读取者继续操作。当没有读取者的时候，服务器再次开始插入延迟的数据行。这个过程一直进行，直到队列空了为止。几点要注意事项：
# INSERT DELAYED应该仅用于指定值清单的INSERT语句。服务器忽略用于INSERT DELAYED...SELECT语句的DELAYED。
# 服务器忽略用于INSERT DELAYED...ON DUPLICATE UPDATE语句的DELAYED。
# 因为在行被插入前，语句立刻返回，所以您不能使用LAST_INSERT_ID()来获取AUTO_INCREMENT值。AUTO_INCREMENT值可能由语句生成。
# 对于SELECT语句，DELAYED行不可见，直到这些行确实被插入了为止。
# DELAYED在从属复制服务器中被忽略了，因为DELAYED不会在从属服务器中产生与主服务器不一样的数据。注意，目前在队列中的各行只保存在存储器中，直到它们被插入到表中为止。这意味着，如果您强行中止了mysqld（例如，使用kill -9）或者如果mysqld意外停止，则所有没有被写入磁盘的行都会丢失。

<strong>二、IGNORE的使用</strong>
IGNORE是MySQL相对于标准SQL的扩展。如果在新表中有重复关键字，或者当STRICT模式启动后出现警告，则使用IGNORE控制ALTER TABLE的运行。如果没有指定IGNORE，当重复关键字错误发生时，复制操作被放弃，返回前一步骤。如果指定了IGNORE，则对于有重复关键字的行，只使用第一行，其它有冲突的行被删除。并且，对错误值进行修正，使之尽量接近正确值。
insert ignore into tb(...) value(...)这样不用校验是否存在了，有则忽略，无则添加

<strong>三、ON DUPLICATE KEY UPDATE的使用</strong>
如果您指定了ON DUPLICATE KEY UPDATE，并且插入行后会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值，则执行旧行UPDATE。

例如，如果列a被定义为UNIQUE，并且包含值1，则以下两个语句具有相同的效果：
<pre>
mysql>INSERT INTO table (a,b,c) VALUES (1,2,3)      
    ->ON DUPLICATE KEY UPDATE c=c+1;
mysql>UPDATE table SET c=c+1 WHERE a=1;
</pre>
如果行作为新记录被插入，则受影响行的值为1；
如果原有的记录被更新，则受影响行的值为2。

注释：
如果列b也是唯一列，则INSERT与此UPDATE语句相当：
<pre>mysql>UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;</pre>
如果a=1 OR b=2与多个行向匹配，则只有一个行被更新。
通常，您应该尽量避免对带有多个唯一关键字的表使用ON DUPLICATE KEY子句。您可以在UPDATE子句中使用VALUES(col_name)函数从INSERT...UPDATE语句的INSERT部分引用列值。换句话说，如果没有发生重复关键字冲突，则UPDATE子句中的VALUES(col_name)可以引用被插入的col_name的值。本函数特别适用于多行插入。VALUES()函数只在INSERT...UPDATE语句中有意义，其它时候会返回NULL。
示例：
<pre>
mysql>INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)
    ->ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
</pre>
本语句与以下两个语句作用相同：
<pre>
mysql>INSERT INTO table (a,b,c) VALUES (1,2,3)
    ->ON DUPLICATE KEY UPDATE c=3;
mysql>INSERT INTO table (a,b,c) VALUES (4,5,6)
    ->ON DUPLICATE KEY UPDATE c=9;
</pre>
当您使用ON DUPLICATE KEY UPDATE时，DELAYED选项被忽略。

总结：
DELAYED 做为快速插入，并不是很关心失效性，提高插入性能。
ignore    只关注主键对应记录是不存在，无则添加，有则忽略。
ON DUPLICATE KEY UPDATE 在添加时操作，关注非主键列，注意与ignore的区别。有则更新指定列，无则添加。 

<url>http://hi.baidu.com/neonway/blog/item/51c4c158e1b996dd9d820459.html</url>
mysql下的insert/replace/update/deleteINSERT和REPLACE语句的功能都是向表中插入新的数据。这两条语句的语法类似。它们的主要区别是如何处理重复的数据。

</zenbossCode>

<h3>INSERT的一般用法</h3>
<zenbossCode>
MySQL中的INSERT语句和标准的INSERT不太一样，在标准的SQL语句中，一次插入一条记录的INSERT语句只有一种形式。

　　INSERT INTO tablename(列名…) VALUES(列值);

　　而在MySQL中还有另外一种形式。

　　INSERT INTO tablename SET column_name1 = value1, column_name2 = value2，…;

　　第一种方法将列名和列值分开了，在使用时，列名必须和列值的数一致。如下面的语句向users表中插入了一条记录：

　　INSERT INTO users(id, name, age) VALUES(123, '姚明', 25);

　　第二种方法允许列名和列值成对出现和使用，如下面的语句将产生中样的效果。

　　INSERT INTO users SET id = 123, name = '姚明', age = 25;

　　如果使用了SET方式，必须至少为一列赋值。如果某一个字段使用了省缺值（如默认或自增值），这两种方法都可以省略这些字段。如id字段上使用了自增值，上面两条语句可以写成如下形式：

　　INSERT INTO users (name, age) VALUES('姚明',25);

　　INSERT INTO uses SET name = '姚明', age = 25;

　　MySQL在VALUES上也做了些变化。如果VALUES中什么都不写，那MySQL将使用表中每一列的默认值来插入新记录。

　　INSERT INTO users () VALUES();

　　如果表名后什么都不写，就表示向表中所有的字段赋值。使用这种方式，不仅在VALUES中的值要和列数一致，而且顺序不能颠倒。 INSERT INTO users VALUES(123, '姚明', 25);

　　如果将INSERT语句写成如下形式MySQL将会报错。

　　INSERT INTO users VALUES('姚明',25);
</zenbossCode>


</div>
	

</body>
</html>